<!DOCTYPE html>
<html>
<head>
<title>Lab7</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Lab 7: AI with steering and player seek behaviours</h2>
<p><strong>To be completed by:</strong> Week 18 (Fri 1/2)</p>
<p>Learning Outcomes:</p>
<ul>
<li>Explain the operation of a steering algorithm with collision avoidance.</li>
<li>Implement seek and collision avoidance behaviour for an AI tank opponent.</li>
</ul>
<hr />
<p><strong>7.1 Introduction</strong></p>
<p>In this lab, we will add an AI tank that will use a basic steering algorithm to track the player and steer around obstacles. First you must read <a href="https://gamedevelopment.tutsplus.com/tutorials/understanding-steering-behaviors-collision-avoidance--gamedev-7777">this article</a> which explains how a steering algorithm with collision avoidance works. You should be able to follow the logic of this article with just a basic understanding of vector maths - the code examples are illustrated in pseudocode similar to C#/C++.</p>
<p>Now that you have read the article, download the source files for this lab from <a href="https://1drv.ms/u/s!AoRoV1R6G7iCtg7j_fvSpQmPjUpU">here</a>. </p>
<p>Copy TankAI.h to <code>include</code> and TankAI.cpp to <code>src</code>.</p>
<p>Don't forget to add these files to your project.</p>
<p><strong>7.2 Refactoring the existing code base</strong></p>
<p>Next, we need to refactor or change our existing code base to accomodate the new functionality of an AI opponent. Firstly, the AI tank will need to know the world coordinates of the player tank, so add a <code>getPosition()</code> member function to class Tank:</p>
<pre><code>/// &lt;summary&gt;
/// @brief Reads the player tank position.
/// &lt;returns&gt;The tank base position.&lt;/returns&gt;
/// &lt;/summary&gt;
sf::Vector2f getPosition() const;
</code></pre>

<p>and in Tank.cpp:</p>
<pre><code>////////////////////////////////////////////////////////////
sf::Vector2f Tank::getPosition() const
{
    return m_tankBase.getPosition();
}
</code></pre>

<p>Next, we have defined some properties of the AI tank in the YAML file - look at the <code>ai_tank</code> section below:</p>
<pre><code>background:
   file: ./resources/images/Background.jpg # Sample comment
tank:
   position: {x: 800, y: 100}
   max_projectiles: 10
   reload_time: 1000  
ai_tank:
   position: {x: 400, y: 700}
   max_projectiles: 10
   reload_time: 1000 
</code></pre>

<p>What is of immediate interest is it's starting position in the world. In LevelLoader.h we need to modify the <code>LevelData</code> struct to add an instance of the AI tank data:</p>
<pre><code>struct LevelData
{
   BackgroundData m_background;
   TankData m_tank;
   TankData m_aiTank; // ADD THIS
   std::vector&lt;ObstacleData&gt; m_obstacles;
};
</code></pre>

<p>Then in LevelLoader.cpp, we add a line to parse the AI tank data from the YAML file. </p>
<pre><code>////////////////////////////////////////////////////////////
void operator &gt;&gt; (const YAML::Node&amp; levelNode, LevelData&amp; level)
{
   levelNode[&quot;background&quot;] &gt;&gt; level.m_background;

   levelNode[&quot;tank&quot;] &gt;&gt; level.m_tank;

   levelNode[&quot;ai_tank&quot;] &gt;&gt; level.m_aiTank;  // ADD THIS
</code></pre>

<p>Next, we need to modify the Game class to add an instance of the TankAi class. In Game.h, add the following member variable:</p>
<pre><code>// An instance representing the AI controlled tank.
TankAi m_aiTank;
</code></pre>

<p>In Game.cpp, initialise <code>m_aiTank</code> in the Game constructor:</p>
<pre><code>Game::Game()
: m_window(sf::VideoMode(1440, 900, 32), &quot;SFML Playground&quot;, sf::Style::Default)
, m_tank(m_texture, m_wallSprites)
, m_aiTank(m_texture, m_wallSprites)    // ADD THIS
</code></pre>

<p>Notice how we pass the container of wall sprites to the AI tank. It requires this information in order to draw the collision circles around each obstacle as outlined in the article you have read. How are the collision circles drawn and stored? If you have a look at the TankAi::init() in TankAi.cpp:</p>
<pre><code>void TankAi::init()
{
    ...
    for (sf::Sprite const wallSprite : m_wallSprites)
    {
        sf::CircleShape circle(wallSprite.getTextureRect().width * 1.5f);
        circle.setOrigin(circle.getRadius(), circle.getRadius());
        circle.setPosition(wallSprite.getPosition());
        m_obstacles.push_back(circle);
    }
}
</code></pre>

<p>This function processes each wall sprite in the container <code>m_wallSprites</code>. For each wall, we create an <code>sf::CircleShape</code> whose radius is 1.5 times the width of the wall sprite. The circle is positioned over the wall and then added to a container called <code>m_obstacles</code>. Note that the circles are never drawn (you can draw them if you wish for debug purposes). </p>
<p>Next, at the very end of the Game constructor body, you need to call <code>TankAi::init()</code>:</p>
<pre><code>// Populate the obstacle list and set the AI tank position.
m_aiTank.init(m_level.m_aiTank.m_position);
</code></pre>

<p>Finally, add some code to update the AI tank (hint: <code>Game::update()</code>), and also render it (hint: <code>Game::render()</code>).</p>
<p><strong>Exercise 1:</strong> Build and run the project - You should see an AI tank drawn in the bottom left corner, but it doesn't move yet.</p>
<p><strong>Exercise 2:</strong> The actual AI steering code for the AI tank is defined in the TankAi class (TankAI.h/.cpp). Complete the implementation of the <code>TankAi::seek()</code> function by following the logic described from the article. Build and run the project when have completed this task. Using the debugger, can you explain why the AI tank follows the particular path you can observe? (Hint: have a look at what is going on inside <code>TankAI::collisionAvoidance()</code>)</p>
<p><strong>Exercise 3:</strong> Again, using the article as a guide, complete the implementation of the <code>TankAi::findMostThreatening()</code> member function. Hint: note the <code>MathUtility</code> namespace provides <code>MathUtility::lineIntersectsCircle()</code> and <code>MathUtility::distance()</code> functions that will help you.</p>
<p><strong>Exercise 4:</strong> For a slight variation on the steering behaviour, we can also calculate an acceleration using the mass of the AI Tank, so bigger things can be slow and have &quot;more inertia&quot;. In TankAI::update(), try adding the new lines below and observe the new steering behaviour:</p>
<pre><code>    sf::Vector2f acceleration; // ADD THIS
    switch (m_aiBehaviour)
    {
    case AiBehaviour::SEEK_PLAYER:
        m_steering += thor::unitVector(vectorToPlayer);
        m_steering += collisionAvoidance();
        m_steering = MathUtility::truncate(m_steering, MAX_FORCE);
        acceleration = m_steering / MASS;  // ADD THIS
        // Comment the line below out:
        // m_velocity = MathUtility::truncate(m_velocity + m_steering, MAX_SPEED);
        // Add the new line below:
        m_velocity = MathUtility::truncate(m_velocity + acceleration, MAX_SPEED);
</code></pre>

<p>You will need to add MASS as a constant with an initial value of 100.0f. Notice how the tank accelerates and steers very slowly causing the collision avoidance to fail. What happens if you reduce the MASS by a factor of 10, i.e. to 10.0f? Does this improve the steering behaviour?</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
