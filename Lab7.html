<!DOCTYPE html>
<html>
<head>
<title>Lab7</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Lab 7: Introduction to EntityX - an Entity Component System - Part 2</h2>
<p><strong>To be completed by:</strong> Week 17 (Fri 27/1)</p>
<p>Learning Outcomes:</p>
<ul>
<li>Explain how systems are created and updated from a game loop</li>
<li>Demonstrate iterator style traversal of components and show how entities and components
  are processed in such a loop.</li>
<li>Explain the purpose and operation of the RenderSystem and MovementSystem in the tank demo.</li>
<li>Add a complete new system to the tank demo.</li>
</ul>
<hr />
<p><strong>7.1 Introduction</strong></p>
<p>In the previous lab, we looked at the LevelSystem and saw how it had responsibility for creating the Entities and Components we need for the tank demo. However, this system is a bit of an oddity in the sense that it performs no function inside our game loop, i.e. the <code>LevelSystem::update()</code> method is empty. Most systems contribute some functionality to the main game loop, and will look at examples of such systems shortly. </p>
<p>Systems process entities and their components, and this can be achieved with what is referred to
as iterator-style traversal of components. For example, if we want to process all entities that have a Position, we could write a loop like this:</p>
<pre><code>Position::Handle position;

for (Entity entity : entities.entities_with_components(position)) {
  // Do things with entity and position
}
</code></pre>

<p>This loop will iterate through the all the available entities that have a <code>Position</code> component. This is achieved by calling the <code>entities_with_components()</code> method on the <code>EntityManager</code> object, i.e. <code>entities.entities_with_components(position)</code></p>
<p>The variable <code>entity</code> can be accessed inside the loop and the variable <code>position</code> is instantiated with the value of the <code>Position</code> component that belongs to that entity. </p>
<p>Now, lets consider a concrete example of two other systems from our demo.</p>
<p><strong>7.2 The RenderSystem</strong></p>
<p>The RenderSystem is primarily responsible for rendering or drawing everything we see in the world. This includes the background, any obstacles in the level, the tank and turret etc.
The <code>RenderSystem</code> class has two sprites as member variables - one for the background (<code>m_bgSprite</code>) and one for the sprite sheet (<code>m_sprite</code>). Let's consider the first loop defined inside the <code>RenderSystem::update()</code> method (note that this <code>update()</code> method is called from our main game loop inside <code>Game::update()</code>)</p>
<pre><code>void RenderSystem::update(EntityManager &amp;entities,
                          EventManager &amp;events,
                          double dt)
{
   m_window.clear(sf::Color::Black);

   Background::Handle background;
   Position::Handle position;
   for (Entity entity : entities.entities_with_components(background, position))
   {
      m_bgSprite.setTextureRect(sf::IntRect(0, position-&gt;m_position.y, ScreenSize::width(), ScreenSize::height()));
      m_window.draw(m_bgSprite);
   }   
   ...
</code></pre>

<p>The background is cleared to black. Then two local variables are defined - these will be used to store the data in the <code>Background</code> and <code>Position</code> components respectively. The loop will clearly process all entities that have a <code>Background</code> and a <code>Position</code> component. There is only one entity that have these two components, so our loop will execute once. If you have a look at the component defined in Background.h/Background.cpp, you will see it has no data. The <code>Background</code> component is purely used to distinguish an Entity having a <code>Position</code> component as a background entity (not a foreground entity such as the tank).</p>
<p>The body of the loop defines an <code>sf::IntRect</code> to fill the screen. Notice the the reference to the position component to get the y-value (<code>position-&gt;m_position.y</code>). The background sprite is then drawn.</p>
<p>The remainder of <code>RenderSystem::update()</code> method is as follows:</p>
<pre><code>   Display::Handle display;
   for (Entity entity : entities.entities_with_components(position, display))
   {
       if (!isOutsideScreen(position-&gt;m_position, display-&gt;m_coord.width, display-&gt;m_coord.height))
       {
           m_sprite.setOrigin(display-&gt;m_coord.width / 2.0, display-&gt;m_coord.height / 2.0);
           if (entity.has_component&lt;Turret&gt;())
           { 
               m_sprite.setOrigin(display-&gt;m_coord.width / 3.0, display-&gt;m_coord.height / 2.0);              
           }                    
           m_sprite.setPosition(position-&gt;m_position;);
           m_sprite.setRotation(position-&gt;m_rotation);       
           m_sprite.setTextureRect(display-&gt;m_coord);
           m_sprite.setColor(display-&gt;m_color);      
           m_window.draw(m_sprite);        
       }
       else
       {
           entity.destroy();
       }
   }
</code></pre>

<p>This will process all entities that have a <code>Position</code> and a <code>Display</code> component. The <code>if</code> statement calls a helper function called <code>isOutSideScreen()</code> that checks if this entity is off-screen. If it not off-screen, the origin, position, rotation and texture rectangle of the sprite are set and it is rendered. If the sprite is completely off-screen, the corresponding entity is destroyed, although this should not happen in this demo.</p>
<p><strong>7.3 The MovementSystem</strong></p>
<p>The purpose of the MovementSystem is to compute the new positions of any relevant entities such as the tank/turret. Let's consider the first loop in <code>MovementSystem::update()</code> </p>
<pre><code>   Motion::Handle motion;
   Position::Handle position;

   for (entityx::Entity entity : entities.entities_with_components(motion, position))
   {             

        sf::Vector2f newPos(position-&gt;m_position.x + std::cos(DEG_TO_RAD  * position-&gt;m_rotation) * motion-&gt;m_speed * (dt / 1000),
               position-&gt;m_position.y + std::sin(DEG_TO_RAD  * position-&gt;m_rotation) * motion-&gt;m_speed * (dt / 1000));

        if (!isOnScreen(newPos, entity))         
        {                       
            motion-&gt;m_speed = 0;
            continue;
        }
        position-&gt;m_position.x = newPos.x;
        position-&gt;m_position.y = newPos.y;      
   }
</code></pre>

<p>This is quite straightforward - any entities that have a Motion and Position component have a new position calculated into a temporary variable called <code>newPos</code>. The <code>if</code> statement checks via a helper method <code>isOnScreen()</code> whether any entity has moved just outside the bounds of the display. If so, the speed attribute of their motion component is set to 0 and the <code>continue</code> statement will skip the remaining statements in the loop so their new position is not set. The last two lines update the position component to the value of our temporary variable <code>newPos</code>.
Don't forget the RenderSystem will use the updated values that are set here when drawing the sprites on screen.</p>
<p>The reminder of <code>MovementSystem::update()</code> is as follows:</p>
<pre><code>   Parent::Handle parent;
   for (entityx::Entity entity : entities.entities_with_components(position, parent))
   {
       // Retrieve the Position component from the parent entity
       // Note the variable parent is a component, it has a member variable called m_parentEntity which is a 
       //  reference to the tank entity (i.e. m_parentEntity).
       Position::Handle parentPosition = parent-&gt;m_parentEntity.component&lt;Position&gt;();
       position-&gt;m_position.x = parentPosition-&gt;m_position.x;
       position-&gt;m_position.y = parentPosition-&gt;m_position.y;      
   }
</code></pre>

<p>This loop simply processes any entities that have both a <code>Position</code> and a <code>Parent</code> component, i.e. the entity representing the Turret. The purpose of the loop is to ensure the Turret's position is set to that of it's parent entity (the tank base).
Clearly, the tank does not move because we don't have a system to process any key input. This is the focus of the following exercise.</p>
<p><strong>Exercise 1:</strong> Download the required source files from <a href="https://1drv.ms/u/s!AoRoV1R6G7iCsm3MGXeUQzcYvWb8">here</a>.  </p>
<p>Copy KeyHandler.h and KeyHandler.cpp to your <code>include</code> and <code>src</code> folders respectively.</p>
<p>Copy PlayerControlSystem.h to your <code>include\systems</code> folder and PlayerControlSystem.cpp to your <code>src\systems</code> folder.</p>
<p>Copy PlayerControl.h to your <code>include\components</code> folder and PlayerControl.cpp to your <code>src\components</code> folder.</p>
<p>Don't forget to add all these files to your project.</p>
<p>In Game.h, create a new member variable:</p>
<pre><code>KeyHandler m_keyHandler;    // N.B. be sure to #include &quot;KeyHandler.h&quot;
</code></pre>

<p>In Game.cpp, add the following lines to <code>switch</code> statement inside member function <code>Game::processInput()</code></p>
<pre><code>    case sf::Event::KeyPressed: 
        m_eventManager.emit&lt;EvKeyboard&gt;(event.key.code, true);
        m_keyHandler.updateKey(event.key.code, true);   
        break;
    case sf::Event::KeyReleased:
        m_eventManager.emit&lt;EvKeyboard&gt;(event.key.code, false);
        m_keyHandler.updateKey(event.key.code, false);              
        break;
</code></pre>

<p>The event <code>EvKeyboard</code> is not yet defined, so open Events.h and add it as follows:</p>
<pre><code>/// &lt;summary&gt;
/// A keyboard event.
/// &lt;/summary&gt;
struct EvKeyboard : public entityx::Event&lt;EvKeyboard&gt;
{
    /// &lt;summary&gt;
    /// Constructs this event with the key and key pressed status parameters.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;key&quot;&gt;the SFML key associated with this event&lt;/param&gt;
    /// &lt;param name=&quot;score&quot;&gt;if true, key is down&lt;/param&gt;
    /// &lt;/summary&gt;
    EvKeyboard(sf::Keyboard::Key key, bool isDown)
        : m_key(key)
        , m_isDown(isDown)
    {
    }

    sf::Keyboard::Key m_key;
    bool m_isDown;
};
</code></pre>

<p>You will need to <code>#include &lt;SFML/Window/Keyboard.hpp&gt;</code> at the top of Events.h because <code>sf::Keyboard::Key</code> is defined in that header file.</p>
<p>In EntityCreator.cpp, assign the <code>PlayerControl</code> component to both the tank base and the turret. <strong>Note</strong> - this component should only be assigned if the tank base/turret are not controlled by the AI.</p>
<p>Make the required changes to Game.cpp so that keyboard input can now control the tank.</p>
<p>Hint: look at how the other systems are created and updated.</p>
<p><strong>Exercise 2:</strong> The purpose of the questions below is to help your understanding of how Systems work in this project. Open Notepad and save the file as Lab7Answers.txt. Write your answer to each question below into this file.</p>
<p><strong>2.1</strong> What does the first for loop do in MovementSystem.cpp?</p>
<p><strong>2.2</strong> What does the second for loop do in MovementSystem.cpp?</p>
<p><strong>2.3</strong> Where is MovementSystem::update() called?</p>
<p><strong>2.4</strong> In RenderSystem.cpp, what purpose does the <code>Background</code> component have? What Entity is assigned the Background component?</p>
<p><strong>2.5</strong> Open the EntityCreator.cpp. Comment out the line that assigns a <code>Display</code> component to the TankBase. Can you explain what happens?</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
