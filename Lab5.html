<!DOCTYPE html>
<html>
<head>
<title>Lab5</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Lab 5: Detecting Collisions</h2>
<p><strong>To be completed by:</strong> Week 9 (Fri 9/11)</p>
<p>Learning Outcomes:</p>
<ul>
<li>Perform elementary collision detection and response between sprites.</li>
</ul>
<hr />
<p>Continue with the sample Visual Studio solution 'SFML_Playground' from lab 4.</p>
<p><strong>5.1 Project setup</strong></p>
<p>We are going to add a couple of sections of walls to add some interest to the level, when finished it will look like this: </p>
<p><img src="level_with_walls.jpg" /></p>
<p>It will obviously be necessary to check for collisions between the tank and the walls which is the focus of this lab.</p>
<p>Download the necessary files for this lab from <a href="https://1drv.ms/u/s!AoRoV1R6G7iCs24wErcn76NiLQaD">here</a>. Unzip the file and copy the updated .yaml file into your <code>resources\levels</code> folder. The yaml file defines additional walls as obstacles. 
Add the files <code>CollisionDetector.h</code>, <code>OrientedBoundingBox.h</code> and their respective .cpp files to your project.
The <code>OrientedBoundingBox</code> class is adapted slightly from the SFML wiki <a href="https://github.com/SFML/SFML/wiki/Source%3A-Simple-Collision-Detection-for-SFML-2">here</a>. It provides an implementation of the <a href="http://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169">Seperating Axis Theorem</a> which you may learn about in Graphics next year. </p>
<p><strong>5.2 Generating the walls</strong></p>
<p>The first step is to get the level data for the Walls from our <code>Level</code> object - remember, the <code>Game</code> class has a member variable <code>m_level</code> which represents our level data. Note we don't need to make any changes to our <code>LevelLoader</code> as it will happily load up the additional walls we have defined in the yaml file. Add a new private member function to Game.h as follows:</p>
<pre><code>/// &lt;summary&gt;
/// @brief Creates the wall sprites and loads them into a vector.
/// Note that sf::Sprite is considered a light weight class, so 
///  storing copies (instead of pointers to sf::Sprite) in std::vector is acceptable.
/// &lt;/summary&gt;
void generateWalls();
</code></pre>

<p>We will need to create a <code>sf::Sprite</code> for each wall, and because there are multiple walls, we need to store the sprites in a container. Add the following new member variable:</p>
<pre><code>// Wall sprites
std::vector&lt;sf::Sprite&gt; m_wallSprites;
</code></pre>

<p>This defines a <code>std::vector</code> of type <code>sf::Sprite</code>. The vector of course will hold nothing yet, so we need to write the function <code>generateWalls()</code> next to fill it.
In Game.cpp, define the new member function:</p>
<pre><code>////////////////////////////////////////////////////////////
void Game::generateWalls()
{
    sf::IntRect wallRect(2, 129, 33, 23);
    // Create the Walls 
    for (ObstacleData const &amp; obstacle : m_level.m_obstacles)
    {
        sf::Sprite sprite;
        sprite.setTexture(m_texture);
        sprite.setTextureRect(wallRect);
        sprite.setOrigin(wallRect.width / 2.0, wallRect.height / 2.0);
        sprite.setPosition(obstacle.m_position);
        sprite.setRotation(obstacle.m_rotation);
        m_wallSprites.push_back(sprite);
    }
}
</code></pre>

<p>The sprites for each wall are simply appended to the vector. </p>
<p>At the end of the <code>Game</code> constructor function, add a line to call the new member function:</p>
<p><code>generateWalls();</code></p>
<p><strong>Exercise 1</strong>: Build and run the project. Note the walls do not appear. Modify the <code>Game::render()</code> function so the walls get drawn. Hint: Think about what we have just done in the <code>generateWalls()</code> function.</p>
<p><strong>5.3 Collision detection between tank and walls</strong></p>
<p>Now the walls are visible, the next step is to add collision detection between the tank and walls. The tank will perform it's own collision checking. Therefore, we need to tell the tank where the walls are. Refactor the <code>Tank</code> constructor to take a reference to the container of wall sprites (note that we try to keep our comments updated to relect the changes):</p>
<pre><code>/// &lt;summary&gt;
/// @brief Constructor that stores drawable state (texture, sprite) for the tank.
/// Stores references to the texture and container of wall sprites. 
/// Creates sprites for the tank base and turret from the supplied texture.
/// &lt;/summary&gt;
/// &lt;param name=&quot;texture&quot;&gt;A reference to the sprite sheet texture&lt;/param&gt;
///&lt; param name=&quot;texture&quot;&gt;A reference to the container of wall sprites&lt;/param&gt;  
Tank(sf::Texture const &amp; texture, std::vector&lt;sf::Sprite&gt; &amp; wallSprites);
</code></pre>

<p>Next, add a new member variable to keep a reference to the wall sprite container in Tank.h:</p>
<pre><code>// A reference to the container of wall sprites.
std::vector&lt;sf::Sprite&gt; &amp; m_wallSprites;
</code></pre>

<p>The constructor definition now looks like:</p>
<pre><code>////////////////////////////////////////////////////////////
Tank::Tank(sf::Texture const &amp; texture, std::vector&lt;sf::Sprite&gt; &amp; wallSprites)
: m_texture(texture)
, m_wallSprites(wallSprites)
{
    // Initialises the tank base and turret sprites.
    initSprites();
}
</code></pre>

<p>Don't forget to change the call to the tank constructor function in Game.cpp - you will need to pass in the vector of wall sprites.</p>
<p>We now require a new member function in class Tank to check for collisions betweeen the tank and the walls:</p>
<pre><code>/// &lt;summary&gt;
/// @brief Checks for collisions between the tank and the walls.
/// 
/// &lt;/summary&gt;
/// &lt;returns&gt;True if collision detected between tank and wall.&lt;/returns&gt;
bool checkWallCollision();
</code></pre>

<p>And the implementation looks like this:</p>
<pre><code>////////////////////////////////////////////////////////////
bool Tank::checkWallCollision()
{
    for (sf::Sprite const &amp; sprite : m_wallSprites)
    {
        // Checks if either the tank base or turret has collided with the current wall sprite.
        if (CollisionDetector::collision(m_turret, sprite) ||
            CollisionDetector::collision(m_tankBase, sprite))
        {
            return true;
        }
    }
    return false;
}
</code></pre>

<p><code>CollisionDetector::collision()</code> is a static method that takes two sprites and returns true if their bounding boxes intersect. Note how we check both the tank base <strong>AND</strong> the turret for wall collisions. Note: Don't forget to <code>#include &quot;CollisionDetector.h&quot;</code> inside the header file for class <code>Tank</code>.</p>
<p>Build and run the project. Note that the tank still runs through the walls as our <code>Tank::checkWallCollision()</code> function is not called anywhere.</p>
<p><strong>Exercise 2</strong>: In <code>Tank::update()</code> we want to call our collision check function. At the end of <code>update()</code>, add the following:</p>
<pre><code>if (checkWallCollision())
{
    deflect();
}
</code></pre>

<p>There are several collision scenarios we need to take into account:</p>
<p>(1) The tank is moving in a straight line and collides with a wall. In this case we <em>bounce</em> the tank back in the direction of travel and disable turret rotations while this is happening.</p>
<p>(2) The tank is stopped, but it rotates into a wall, so we bounce the tank base in the opposite direction (away from the wall). </p>
<p>(3) Again the tank is not moving, but the turret rotates and collides with an adjacent wall. In this case, we want to deflect the turret back (slightly) in the direction it was moving from. These scenarios are captured below in our new member function <code>deflect()</code> which you can add to Tank.h:</p>
<pre><code>/// &lt;summary&gt;
/// @brief Stops the tank if moving and applies a small increase in speed in the opposite direction of travel.
/// If the tank speed is currently 0, the rotation is set to a value that is less than the previous rotation value
///  (scenario: tank is stopped and rotates into a wall, so it gets rotated towards the opposite direction).
/// If the tank is moving, further rotations are disabled and the previous tank position is restored.
/// The tank speed is adjusted so that it will travel slowly in the opposite direction. The tank rotation 
///  is also adjusted as above if necessary (scenario: tank is both moving and rotating, upon wall collision it's 
///  speed is reversed but with a smaller magnitude, while it is rotated in the opposite direction of it's 
///  pre-collision rotation).
/// &lt;/summary&gt;
void deflect();
</code></pre>

<p>Here's the implementation for <code>Tank::deflect()</code></p>
<pre><code>void Tank::deflect()
{
    // In case tank was rotating.
    adjustRotation();

    // If tank was moving.
    if (m_speed != 0)
    {
        // Temporarily disable turret rotations on collision.
        m_enableRotation = false;
        // Back up to position in previous frame.
        m_tankBase.setPosition(m_previousPosition);
        // Apply small force in opposite direction of travel.
        if (m_previousSpeed &lt; 0)
        {
            m_speed = 8;
        }
        else
        {
            m_speed = -8;           
        }
    }
}
</code></pre>

<p>Firstly, you will need to add new member variables <code>m_enableRotation</code>, <code>m_previousPosition</code> and <code>m_previousSpeed</code>. Rotations should be enabled initially, but are disabled when there is a collision. Rotations should be re-enabled after a collision has been resolved (think about where this should happen).
The variable <code>m_previousPosition</code> should always be updated before the tank moves to a new position.
We will deal with <code>m_previousSpeed</code> shortly.</p>
<p>Next, add a new private member function for <code>adjustRotation()</code>:</p>
<pre><code>void adjustRotation();
</code></pre>

<p>with the following implementation:</p>
<pre><code>////////////////////////////////////////////////////////////
void Tank::adjustRotation()
{
    // If tank was rotating...
    if (m_rotation != m_previousRotation)
    {
        // Work out which direction to rotate the tank base post-collision.
        if (m_rotation &gt; m_previousRotation)
        {
            m_rotation = m_previousRotation - 1;
        }
        else
        {
            m_rotation = m_previousRotation + 1;
        }
    }
    // If turret was rotating while tank was moving
    if (m_turretRotation != m_previousTurretRotation)
    {
        // Set the turret rotation back to it's pre-collision value.
        m_turretRotation = m_previousTurretRotation;
    }
}
</code></pre>

<p>The last two new member variable we need are <code>m_previousRotation</code> and <code>m_previousTurretRotation</code> to keep track of the previous tank base and turrent rotations respectively. Add these now. 
Note that <code>m_previousRotation</code> should save the tank bases current rotation value before it gets updated. Where should this be done? (Likewise with <code>m_previousTurretRotation</code>).</p>
<p>Hint: Take a look at where we might capture the current tank base rotation before it gets updated:</p>
<pre><code>////////////////////////////////////////////////////////////
void Tank::increaseRotation()
{
    m_previousRotation = m_rotation; // NEW
    m_rotation += 1;
    if (m_rotation == 360.0)
    {
        m_rotation = 0;
    }
}
</code></pre>

<p>Do the same now inside member function <code>Tank::decreaseRotation()</code>. Carry out the same procedure for the other member variables <code>m_previousTurretRotation</code> and <code>m_previousSpeed</code>.</p>
<p>Build and run the project - test all three possible collision scenarios. The results are not perfect but work reasonably well.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
