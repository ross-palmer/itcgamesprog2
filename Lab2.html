<!DOCTYPE html>
<html>
<head>
<title>Lab2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Lab 2: Parsing YAML data and displaying text in SFML</h2>
<p><strong>To be completed by:</strong> Week 7 (Fri 28/10)</p>
<p>Learning Outcomes:</p>
<ul>
<li>Explain what YAML is and how it can be used to represent game data.</li>
<li>Use a YAML parser to extract information from a YAML file.</li>
<li>Load a font and show text in SFML.</li>
</ul>
<hr />
<p>Contine with the sample Visual Studio solution 'SFML Playground' from lab 1.</p>
<p><strong>2.1 The YAML format</strong></p>
<p>YAML is a recursive acronomyn that is expanded as:</p>
<blockquote>
<p>YAML Ain't a Markup Language.</p>
</blockquote>
<p>As stated in it's title, YAML is not a markup langauge and allows for more readable code. The following example illustrates this point by comparing a sample XML file against an equivalent YAML file: (taken from <a href="http://www.gamedev.net/page/resources/_/technical/apis-and-tools/yaml-basics-and-parsing-with-yaml-cpp-r3508">here</a>).</p>
<p><strong>Sample XML file</strong></p>
<pre><code>&lt;settings&gt;
    &lt;graphics&gt;
        &lt;vsync&gt;true&lt;/vsync&gt;
        &lt;quality&gt;ultrahigh&lt;/quality&gt;
        &lt;resolution&gt;
            &lt;width&gt;1920&lt;/width&gt;
            &lt;height&gt;1080&lt;/height&gt;
        &lt;/resolution&gt;
    &lt;/graphics&gt;

    &lt;gameplay&gt;
        &lt;difficulty&gt;hard&lt;/difficulty&gt;
        &lt;invert_y&gt;false&lt;/invert_y&gt;
    &lt;/gameplay&gt;
&lt;/settings&gt;
</code></pre>

<p><strong>An equivalent YAML file</strong></p>
<pre><code>settings:
    graphics:
        vsync: true
        quality: ultrahigh
        resolution:
            width: 1920
            height: 1080

    gameplay:
        difficulty: hard
        invert_y: false
</code></pre>

<p>So YAML is a data serialisation language that is designed to be easily read by humans. 
Game data includes elements such as image filenames, image dimensions, attributes of specific game objects (e.g. initial health values, time-to-live value for bullets etc) and so on. It is always a good idea to keep this type of data external to your code base. Why? One reason is to avoid the necessity to rebuild the project when any specific piece of game data changes. For example during playtesting we may discover that the velocity of an AI unit is too high and should be lowered. Once the value is adjusted in the data file, we can re-run the program immediately and see the effect. Another advantage is to keep all the game data together in one external file where it is simpler to manage than looking through source files.</p>
<p>Now we consider a very brief introduction to YAML so we can get up and running with a simple example. YAML has three basic structures: scalars, sequences and mappings. </p>
<p><strong>YAML scalars</strong></p>
<p>Scalars are simple values, such as strings or numbers that may have an optional identifying name. Here's an example that maps scalars to scalars:</p>
<pre><code>file: background.png # This is a simple string scalar
spawn_interval: 20 # This is a simple number scalar
</code></pre>

<p>Note the # symbol designates a comment. Mappings use a colon and a space (&quot;: &quot;) to mark each mapping key: value pair (e.g. in the above, <code>file:</code> maps to <code>background.png</code>). In YAML terminology, <code>file:</code> is a <em>scalar node</em> and it's value is <code>background.png</code>.</p>
<p><strong>YAML sequences</strong></p>
<p>In YAML, block sequences (or lists) indicate each entry with a dash and space (&quot;- &quot;). For example, a sequence of scalars looks like this:</p>
<pre><code>game_developers:
- John McCarmack
- Brenda Romero
- Sid Meier
</code></pre>

<p>Note that tabs <strong>are not</strong> allowed in YAML. White spaces are meaningful when starting a line and are used to identify blocks (through indentation).
Lists are used to store a collection of ordered values. The values are not associated with a key, only with a positional index obtained from the order in which they are specified.</p>
<p><strong>YAML mappings</strong></p>
<p>The value associated to a key can also be another map of key-value pairs. To achieve this, omit the value and instead write the key-value pairs in the following lines. However, you must prefix them with at least one more space character than the key. Here's an example:</p>
<pre><code>background:
   file: background.png # The key background: maps to a key/value pair.
tank:
   file: tank.png
   armour: 100 
</code></pre>

<p>YAML will consider that lines prefixed with more spaces than the parent key are contained inside it. In fact, all lines must be prefixed with the same amount of spaces to belong to the same map. In the above example, the key/value pairs <code>file:</code> and <code>armour:</code> belong to the key <code>tank:</code></p>
<p>Note that:</p>
<pre><code> tank:
   position:
     x: 850
     y: 100
</code></pre>

<p>can also be written as:</p>
<pre><code>tank:
   position: {x: 850, y: 100}
</code></pre>

<p>Finally, it is possible to have mappings inside sequences. Consider this example:</p>
<pre><code>obstacles: 
   - type: wall
     position: {x: 100, y: 660}
     rotation: 0
   - type: wall
     position: {x: 134, y: 662}
     rotation: 10
   - type: wall
     position: {x: 167, y: 670}
     rotation: 20
</code></pre>

<p>This describes an obstacle key that is a sequence of mappings. The mappings are type (each type is a wall), position and rotation. </p>
<p>Next we look at setting up our Visual Studio project to put together a complete example.
If you want to learn more about YAML, have a look at these resources:</p>
<ul>
<li>https://github.com/Animosity/CraftIRC/wiki/Complete-idiot's-introduction-to-yaml</li>
<li>http://yaml.org/spec/current.html</li>
<li>http://www.gamedev.net/page/resources/_/technical/apis-and-tools/yaml-basics-and-parsing-with-yaml-cpp-r3508</li>
</ul>
<p><strong>2.2 Project setup</strong></p>
<p>We need a way of decoding or parsing the YAML information and loading it into a C++ class. We are going to use a C++ YAML parser called <a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a>. </p>
<p>1) To begin, download all the source files from <a href="https://1drv.ms/u/s!AoRoV1R6G7iCsjGwudVsCOwyRW80">here</a>.
Extract the downloaded file and copy the folder named 'yaml-cpp' into your project directory.</p>
<p>2) Copy the files <code>level1.yaml</code> and <code>Background.jpg</code> into your solution folder.</p>
<p>3) In your solution folder, create a folder called <code>lib</code> and copy the file <code>libyaml-cppmdd.lib</code> into that folder. This file contains pre-compiled functions from the YAML library that the linker requires.</p>
<p>4) Inside visual studio, right click your solution name and choose properties. In the Property Pages dialog box, choose <code>Linker-&gt;General</code> and add the entry <code>.\lib</code> under <code>Additional Library Directories</code> as indicated below:</p>
<p><img src="https://ross-palmer.github.io/itcgamesprog2/LinkerYAMLSettings.jpg" /></p>
<p>This tells the linker to search in the current directory (designated as a .) for a folder called <code>lib</code>. How does the linker know what lib file to search for? We need to tell it which is the next step.</p>
<p>5) Open main.cpp and before the first <code>#include</code> statement, add the line:</p>
<pre><code>#pragma comment(lib,&quot;libyaml-cppmdd&quot;) 
</code></pre>

<p>This tells the linker to use the lib file named inside the double quotes.</p>
<p>6) Locate the files LevelLoader.h, LevelLoader.cpp that you downloaded from step 1) and add them to your project.</p>
<p>7) Open Game.h and add the line:</p>
<pre><code>#include LevelLoader.h
</code></pre>

<p><strong>2.3 Introducing <code>std::vector</code></strong></p>
<p>Our <code>LevelLoader</code> class uses a C++ data structure called <code>vector</code>, so we introduce it first here. The C++ <code>std::vector</code> class is a type of container from the Standard Template Library (STL). It should not be confused with a mathematical vector. For now, simply think of a C++ vector as an array that can grow and shrink at runtime. This special attribute means we do not have to declare the size of the vector up front (as we do with arrays). To use it in our program, we must </p>
<p><code>#include &lt;vector&gt;</code> </p>
<p>Note this <code>#include</code> statement is already added to LevelLoader.h </p>
<p>The vector class is defined in the standard (<code>std</code>) namespace and uses special notation to indicate what type of data it can store. For example:</p>
<pre><code>std::vector&lt;int&gt; myVector;
</code></pre>

<p>declares a variable <code>myVector</code> that can store type <code>int</code>. The angle brackets means that
vector is a <em>template</em> class, and a data type is <strong>always</strong> required inside the angle brackets (to fill the template if you like).
We will learn how to add elements to and retrieve elements from a vector shortly.</p>
<p><strong>2.4 How the YAML parser works</strong></p>
<p>The LevelLoader class uses the YAML parser to extract the data from the file (<code>level1.yaml</code>) into the various structs defined inside LevelLoader.h
There is a struct defined for each type of top level YAML node defined in the YAML file, i.e. we have three structs <code>ObstacleData</code>, <code>BackgroundData</code> and <code>TankData</code>.</p>
<p>For example, our obstacle data has a type (a <code>std::string</code>), a position (a <code>sf::Vector2f</code>) and a rotation (a <code>double</code>).</p>
<pre><code>struct ObstacleData
{
  std::string m_type;
  sf::Vector2f m_position;
  double m_rotation;
};
</code></pre>

<p>We have one final struct that aggregates the three structs into one called <code>LevelData</code>:</p>
<pre><code>struct LevelData
{
   BackgroundData m_background;
   TankData m_tank;
   std::vector&lt;ObstacleData&gt; m_obstacles;
};
</code></pre>

<p>Note that <code>m_obstacles</code> is a <code>std::vector</code> of type <code>ObstacleData</code>.</p>
<p>At the end of LevelLoader.h we have a constructor function and a static function called <code>load</code> that takes an integer representing the level number and a reference to a <code>LevelData</code> struct.</p>
<pre><code>class LevelLoader
{
public:

   LevelLoader();

   static bool load(int nr, LevelData&amp; level);
};
</code></pre>

<p><strong>Exercise 1:</strong> In <code>Game.h</code>, add a member variable for the level data:</p>
<pre><code>// Load the game level data.
LevelData m_level;
</code></pre>

<p>In Game.cpp, at the start of the constructor function add the following:</p>
<pre><code>int currentLevel = 1;

if (!LevelLoader::load(currentLevel, m_level))
{
    return;
}
</code></pre>

<p>This calls our static load function passing the level number (1) and a reference to the data structure representing our level (<code>m_level</code>). We will look at the implementation of <code>LevelLoader::load()</code> in a moment.
To confirm everything is setup correctly, build and run the application (you won't see any new output yet). </p>
<p><strong>The <code>LevelLoader::load()</code> function</strong></p>
<p>This is where the yaml parser is used. Here's the first piece of the function:</p>
<pre><code>bool LevelLoader::load(int nr, LevelData&amp; level)
{
   std::stringstream ss;
   ss &lt;&lt; &quot;level&quot;;
   ss &lt;&lt; nr;
   ss &lt;&lt; &quot;.yaml&quot;;
   ...
</code></pre>

<p>The first line declares a <code>std::stringstream</code> object which can be used to concatenate strings and also convert numerics to strings. It is used just like the object <code>cout</code> - note the use of the insertion operator (<code>&lt;&lt;</code>). The lines:</p>
<pre><code>ss &lt;&lt; &quot;level&quot;;
ss &lt;&lt; nr;
ss &lt;&lt; &quot;.yaml&quot;;
</code></pre>

<p>add the string <code>&quot;level&quot;</code>, followed by the value of variable <code>nr</code> (which is 1), followed by the string <code>&quot;.yaml&quot;</code>. Thus, our stringstring object <code>ss</code> now contains the string <code>&quot;level1.yaml&quot;</code>.</p>
<p>The next part of the function defines a try block - this is a block where we may expect an exception (run time problem) to occur and that it should be handled in one of the following catch blocks.</p>
<pre><code>try
{
    YAML::Node baseNode = YAML::LoadFile(ss.str());
    if (baseNode.IsNull())
    {
        std::string message(&quot;file: &quot; + ss.str() + &quot; not found&quot;);
        throw std::exception(message.c_str());
    }
    baseNode &gt;&gt; level;
}
</code></pre>

<p>We used the <code>YAML::LoadFile</code> API function to load the filename contained inside our <code>stringstream</code> object <code>ss</code> - note that <code>ss.str()</code> simply returns a <code>std::string</code> from the object <code>ss</code> as function <code>LoadFile</code> is expecting a string.
If our YAML file is valid, <code>LoadFile()</code> creates a baseNode representing the top level node from which we can access all the scalar nodes we have defined. If the baseNode is null, meaning our yaml file is invalid (e.g. the file does not exist), then an exception is thrown and our program terminates.
Assuming everything is ok, the next line to execute is:</p>
<pre><code>baseNode &gt;&gt; level;
</code></pre>

<p>This is using the extraction operator, just as we have seen with the object <code>cin</code>.
You may have noticed other strange looking functions defined in LevelLoader.cpp, such as this one:</p>
<pre><code>void operator &gt;&gt; (const YAML::Node&amp; levelNode, LevelData&amp; level)
{
   levelNode[&quot;background&quot;] &gt;&gt; level.m_background;

   levelNode[&quot;tank&quot;] &gt;&gt; level.m_tank;

   const YAML::Node&amp; obstaclesNode = levelNode[&quot;obstacles&quot;].as&lt;YAML::Node&gt;();
   for (unsigned i = 0; i &lt; obstaclesNode.size(); ++i)
   {
      ObstacleData obstacle;
      obstaclesNode[i] &gt;&gt; obstacle;
      level.m_obstacles.push_back(obstacle);
   }
}
</code></pre>

<p>This in fact is the function that will be called as a result of </p>
<pre><code>baseNode &gt;&gt; level;
</code></pre>

<p>This function overloads the extraction operator and C++ will automatically pass <code>baseNode</code> as the first argument and <code>level</code> as the second argument.</p>
<p>Note that this line:</p>
<pre><code>levelNode[&quot;background&quot;] &gt;&gt; level.m_background;
</code></pre>

<p>calls this function:</p>
<pre><code>void operator &gt;&gt; (const YAML::Node&amp; backgroundNode, BackgroundData&amp; background)
{
   background.m_fileName = backgroundNode[&quot;file&quot;].as&lt;std::string&gt;();
}
</code></pre>

<p>which looks up the scalar node <code>&quot;file&quot;</code>, returns the mapped value (<code>Background.jpg</code>) as a <code>std::string</code> and stores it in <code>background.m_filename</code></p>
<p><strong>Exercise 1:</strong> Which function do you think will be called as a result of the line:</p>
<pre><code>levelNode[&quot;tank&quot;] &gt;&gt; level.m_tank;
</code></pre>

<p>What does this function do? See if you can answer the question by using the debugger.</p>
<p>Remember that it is possible to have mappings inside sequences like this:</p>
<pre><code>obstacles: 
   - type: wall
     position: {x: 100, y: 660}
     rotation: 0
   - type: wall
     position: {x: 134, y: 662}
     rotation: 10
   - type: wall
     position: {x: 167, y: 670}
     rotation: 20
</code></pre>

<p>The last part of our above function processes each obstacle:</p>
<pre><code>const YAML::Node&amp; obstaclesNode = levelNode[&quot;obstacles&quot;].as&lt;YAML::Node&gt;();
for (unsigned i = 0; i &lt; obstaclesNode.size(); ++i)
{
    ObstacleData obstacle;
    obstaclesNode[i] &gt;&gt; obstacle;
    level.m_obstacles.push_back(obstacle);   
}
</code></pre>

<p>The first line gets a reference to the node (or key) called 'obstacles'. The loop goes round three times. For each iteration, we populate the <code>ObstacleData</code> struct with the function call:</p>
<pre><code>    obstaclesNode[i] &gt;&gt; obstacle;
</code></pre>

<p>and we add the obstacle to the rear of the vector <code>level.m_obstacles</code> using the method <code>push_back()</code>.</p>
<p><strong>Exercise 2:</strong> In the Game.cpp constructor function, set the position of your tank sprite by using the data loaded into the level object member variable (m_level). Hint: The tank position from the yaml file is 850,100.</p>
<p><strong>Exercise 3:</strong>  In the Game.cpp constructor function, load the background as a sprite using the supplied filename. Hint: The filename is <code>Background.jpg</code></p>
<p><strong>Displaying the obstacle data</strong></p>
<p>The final thing to do is process our obstacle data and learn the basic usage of <code>std::vector</code>. 
Open <code>Game.h</code> and add the following member variable:</p>
<pre><code>std::vector&lt;sf::Sprite&gt;  m_sprites;
</code></pre>

<p>In <code>Game.cpp</code>, add the following code to the end of your Game constructor function:</p>
<pre><code>sf::Sprite sprite;
sprite.setTexture(m_texture);
for (auto &amp;obstacle : m_level.m_obstacles)
{
    sprite.setPosition(obstacle.m_position);
    sprite.rotate(obstacle.m_rotation);
    m_sprites.push_back(sprite);
}
</code></pre>

<p>This creates a temporary sprite variable and we use a C++ 11 range based loop to process each item in the vector. Note the for loop, i.e.</p>
<pre><code>for (auto &amp;obstacle : m_level.m_obstacles)
</code></pre>

<p>the keyword <code>auto</code> means the compiler will deduce the correct type for the variable <code>obstacle</code>, which in this case is type <code>ObstacleData</code>. It does this by looking at the type of the vector that we are looping through, in this case the vector <code>m_obstacles</code>. The use of the <code>&amp;</code> means that we only store a reference to each item in the vector. If we wrote the loop this way:</p>
<pre><code>for (auto obstacle : m_level.m_obstacles)
</code></pre>

<p>it would mean that each item in the vector is <em>copied</em> into the variable obstacle on each pass of the loop, which is an unnecessary copy operation in this case. 
Inside the loop, we position the temporary sprite and apply the correct rotation by using the data from the obstacle object. Finally, we copy the temporary sprite into the vector <code>m_sprites</code>. We need to do this as you will need to draw the sprites inside our <code>render()</code> method. (The obstacles use our tank image, but in our demo which we will build later, they will be walls).</p>
<hr />
<p><strong>Side note:</strong> Sometimes there are reasons why is not a good idea to store containers of instances, particularly if those objects are not lightweight. Firstly, all STL containers copy in and copy out. This means any object you wish to store in a container will be copied into that container, and any object you retrieve from the container will be copied out. Worse still, std::vector will copy all of it's elements to a new location in memory if it runs out of capacity. If you delete an element from a vector, any proceeding elements are copied down one place. For these reasons, it is often preferable to store pointers (or preferably smart pointers) to objects in containers like this:</p>
<pre><code>std::vector&lt;sf::Sprite *&gt; myVector;
</code></pre>

<p>We will similar examples later when we discuss smart pointers.</p>
<hr />
<p><strong>Exercise 4:</strong> Inside the <code>render()</code> member function in Game.cpp, write a range based loop to draw each sprite.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
