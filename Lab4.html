<!DOCTYPE html>
<html>
<head>
<title>Lab4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Lab 4: Introducing the KeyHandler class</h2>
<p><strong>To be completed by:</strong> Week 10 (Fri 18/11)</p>
<p>Learning Outcomes:</p>
<ul>
<li>Implement a solution to handle simultaneous key input in SFML.</li>
<li>Explain the purpose of enabling vertical sync on the SFML window.</li>
<li>Explain the purpose of the STL container <code>std::map</code>.</li>
<li>Demonstrate the basic usage of <code>std::map</code>.</li>
</ul>
<hr />
<p>Continue with the sample Visual Studio solution 'SFML Playground' from lab 3.</p>
<p><strong>4.1 Handling simultaneous key presses.</strong></p>
<p>In this lab, we want to implement a solution to handle simultaneous key presses so that our tank can accelerate/decelerate and rotate at the same time. In doing so, we introduce another type of container from the C++ Standard Template Library (STL) called <code>std::map</code>. 
Start by downloading the source files for this lab from <a href="https://1drv.ms/u/s!AoRoV1R6G7iCsj7O_kIb9QgwdkXJ">here</a> and add them to your project.</p>
<p><strong>The KeyHandler class</strong></p>
<p>In KeyHandler.h notice the declaration of our map data structure:</p>
<pre><code>typedef std::map&lt;sf::Keyboard::Key, bool&gt; KeyMap;
KeyMap m_keyMap;
</code></pre>

<p><code>typedef</code> means type definition and is used to create an alias for any data type in C++. The reason for using a <code>typedef</code> is to essentially shorten a declaration for convenience. In this example, <code>KeyMap</code> is a <code>typedef</code> for <code>std::map&lt;sf::Keyboard::Key, bool&gt;</code> and the member variable <code>m_keyMap</code> is a variable of this type. 
So, what is a map? A map is a data structure that maps one type (known as a key) to another type known as a value. In <code>std::map</code>, the key must be unique, but of course the values do not have to be. In this case the key type is <code>sf::Keyboard::Key</code> and the value type is <code>bool</code>.
We have seen this concept in a different form in YAML data files. The purpose of <code>m_keyMap</code> is to store keycodes that are mapped to a bool status where true indicates the key is down (pressed) and false indicates the key is up (not pressed). For example, if the player presses the Left and Up arrow keys simultaneously, two entries are made in our map like this:</p>
<table>
	<tr>
        <td><b>Key</b></td>
        <td><b>Value</b></td>
    </tr>
    <tr>
        <td>Left arrow</td>
        <td>true</td>
    </tr>
    <tr>
        <td>Up arrow</td>
        <td>true</td>
    </tr>
</table>
<p>When the keys are released, their status will revert to <code>false</code>. Of course the map is initially empty and we have to write the logic to make the above happen.
In KeyHandler.cpp, we have the <code>KeyHandler::updateKey()</code> member function: </p>
<pre><code>void KeyHandler::updateKey(sf::Keyboard::Key key, bool isPressed)
{
   m_keyMap[key] = isPressed;
}
</code></pre>

<p>This function should be called whenever we get a key down OR key up event. The line:</p>
<p><code>m_keyMap[key] = isPressed;</code></p>
<p>makes an entry in the map using the variable <code>key</code> as the map key, and the corresponding value is whatever the value of the bool <code>isPressed</code> happens to be. If the key is already in the map, then no new entry is made and the above line will simply update the value.</p>
<p>The other member function is <code>KeyHandler::isPressed(sf::Keyboard::Key key)</code>:</p>
<pre><code>bool KeyHandler::isPressed(sf::Keyboard::Key key) const
{
   KeyMap::const_iterator it = m_keyMap.find(key);

   if (it != m_keyMap.end())
   {
      return it-&gt;second;
   }

   return false;
}
</code></pre>

<p>This is a simple helper function that returns the &quot;pressed&quot; status of the specified key, i.e. the function will return <code>true</code> or <code>false</code>. It does this by searching the map with: </p>
<pre><code>m_keyMap.find(key)) 
</code></pre>

<p><code>find()</code> returns an iterator - an object that behaves like a pointer. The iterator will either point to the map entry containing the key/value pair or it will point to the map end (<code>m_keyMap.end()</code>) if the key/value pair does not exist. The expression <code>it-&gt;second</code> returns the value (or the second part of the pair), which is of course a <code>bool</code>.</p>
<p><strong>Exercise 1:</strong> Refactor the member function <code>Game::processGameEvents()</code> to use our <code>KeyHandler</code> class as follows:</p>
<pre><code>void Game::processGameEvents(sf::Event&amp; event)
{   
    switch (event.type)
    {
        case sf::Event::KeyPressed:         
            m_keyHandler.updateKey(event.key.code, true);
            break;
        case sf::Event::KeyReleased:            
            m_keyHandler.updateKey(event.key.code, false);
            break;      
        default:
            break;
    }   
}
</code></pre>

<p>Notice that we now are checking for either a <code>sf::Event::KeyPressed</code> or <code>sf::Event::KeyReleased</code> event as opposed to checking for specific key presses. </p>
<p><strong>Exercise 2:</strong> Add a new member function to <code>Tank</code> called <code>Tank::handleKeyInput()</code>. This function should use the <code>KeyHandler</code> object to check which of the four control keys have been pressed and move/rotate the tank accordingly. Hint: The <code>Tank</code> class will need to store a reference to the <code>KeyHandler</code> object and you will need to pass the <code>KeyHandler</code> object to the <code>Tank</code>constructor function.</p>
<p><strong>Exercise 3:</strong> Call the  function from the start of <code>Tank::update()</code>.
What happens? </p>
<p><strong>Exercise 4:</strong> Add a line to the beginning of the Game constructor function:</p>
<pre><code>m_window.setVerticalSyncEnabled(true);
</code></pre>

<p>Build and run the project. Can you explain the difference in behaviour now?</p>
<p><strong>Exercise 5:</strong> The turret should be able to rotate independently by moving the Z and X keys. Add this functionality to the project.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
