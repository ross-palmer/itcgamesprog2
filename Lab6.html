<!DOCTYPE html>
<html>
<head>
<title>Lab6</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Lab 6: Projectiles</h2>
<p><strong>To be completed by:</strong> Week 13 (Fri 24/11)</p>
<p>Learning Outcomes:</p>
<ul>
<li>Explain the principles behind the object pool pattern.</li>
<li>Implement a simple pool system for projectiles.</li>
<li>Explain the role of a friend class in C++.</li>
</ul>
<hr />
<p>Continue with the sample Visual Studio solution 'SFML_Playground' from lab 5.</p>
<p><strong>6.1 Implementing a projectile pool</strong></p>
<p>We are now going to implement projectile firing from our tank. We could simply generate projectiles on demand as the user presses fire. However, rather than
allocating and destroying these objects on demand, we keep a set of initialised projectiles in a container (such as an array) ready to be used. A client
of the pool will request a projectile, perform operations on it and it will be 'returned' to the pool when no longer needed. This type of approach is often applied
in cases where many objects need to be generated quickly, and those objects have a short life span.</p>
<p>We will use a game design pattern called the <a href="http://gameprogrammingpatterns.com/object-pool.html">Object Pool pattern</a> to implement a pool of projectiles.<br />
We start with two classes. The first class, <code>Projectile</code>, will store basic information about the projectile such as it's speed and screen position.
The second class, <code>ProjectilePool</code>, will manage a container (pool) of projectiles, and it is through <code>ProjectilePool</code> that we request access to a <code>Projectile</code>.
Let's try and visualise how this will work. Say we have a small pool of 7 projectiles. Initially the pool is full and will look like this:</p>
<p><img src="pool_full.jpg" /></p>
<p>The pool class maintains an index of the next available projectile, which is set to 0 initially. Now imagine that 6 of the 7 projectiles are on-screen.
The pool now looks like this:</p>
<p><img src="pool_almost_empty.jpg" /></p>
<p>The index of the next available projectile points to the last object in the pool. When this object is requested, the pool will now be empty. What do we do if a further projectile is requested from the pool? There are several possible strategies we could take, but the simplest is to wrap the index so that it starts at 0 again:</p>
<p><img src="pool_empty.jpg" /></p>
<p>If a request comes in for another projectile, we must then re-use the projectile at index 0 which is currently on-screen. Note that the position of a projectile
within the array does not tell us anything about how long it has been on-screen, i.e. if projectiles are used in sequence from index 0 to index 6, you cannot assume the 'oldest' projectile will always be at index 0. Projectiles are returned to the pool when they go off-screen or collide with an obstacles such as a wall or another tank.  </p>
<p><strong>6.2 Implementing a projectile pool</strong></p>
<p>Download the necessary files for this lab from <a href="https://1drv.ms/u/s!AoRoV1R6G7iCs3JAZsW_jah0Q80P">here</a>. Unzip the file and add the files <code>Projectile.h</code>, <code>ProjectilePool.h</code> and their respective .cpp files to your project. Let's consider class ProjectilePool first, let's consider it's private data members first:</p>
<pre><code>private:
static const int s_POOL_SIZE = 100;

// A container for the projectiles.
std::array&lt;Projectile, s_POOL_SIZE&gt; m_projectiles;

// The index of the next available projectile.
int m_nextAvailable { 0 };

// A flag indicating whether there are any projectiles available (initially they are).
bool m_poolFull { false };
</code></pre>

<p>So the pool size is 100. We use a C++11 style array to hold the projectile instances. <code>std::array</code> is a template class, the first template argument is the class type you wish to store in the array (<code>Projectile</code>), the second is the size of the array (<code>s_POOL_SIZE</code>). 
The index of the next available projectile is set to 0, and finally we have a flag <code>m_poolFull</code> to keep track of the pool full status.</p>
<p>In the public interface, there is a standard no-op default constructor defined:</p>
<pre><code>/// &lt;summary&gt;
/// @brief No-op default constructor
/// &lt;/summary&gt;
ProjectilePool() = default;
</code></pre>

<p>Note that when we make an instance of ProjectilePool, the array <code>m_projectiles</code> is automatically populated with 100 Projectile instances.
Next, we have a member function called <code>create()</code> which client code will use to request access to a projectile (read the comments to see exactly
what each function does):</p>
<pre><code>/// &lt;summary&gt;
/// @brief Creates a projectile.
/// Creates a projectile from the pool of available projectiles.
///  If no projectiles are available, the next in (pool) sequence after
///  the last used projectile is chosen.
/// &lt;/summary&gt;
/// &lt;param name=&quot;texture&quot;&gt;A reference to the sprite sheet texture&lt;/param&gt;   
/// &lt;param name=&quot;x&quot;&gt;The x position of the projectile&lt;/param&gt;
/// &lt;param name=&quot;x&quot;&gt;The y position of the projectile&lt;/param&gt;
/// &lt;param name=&quot;rotation&quot;&gt;The rotation angle of the projectile in degrees&lt;/param&gt;
void create(sf::Texture const &amp; texture, double x, double y, double rotation);
</code></pre>

<p>The main task of the <code>update()</code> member function is to loop through every projectile in the array and invoke their <code>update()</code> function in turn:</p>
<pre><code>/// &lt;summary&gt;
/// @brief Updates all projectiles in the pool.
/// Sets an index to the next available projectile. Also sets a 
///  status flag to indicate pool full (all projectiles in use).
/// &lt;/summary&gt;
/// &lt;param name=&quot;dt&quot;&gt;The delta time&lt;/param&gt; 
/// &lt;param name=&quot;rotation&quot;&gt;A reference to the container of wall sprites&lt;/param&gt;
void update(double dt, std::vector&lt;sf::Sprite&gt; &amp; wallSprites);
</code></pre>

<p>Finally, the <code>render()</code> member function draws all active projectiles. A projectile is considered active if it's speed value is set (i.e. to it's max. 
possible speed). </p>
<pre><code>/// &lt;summary&gt;
/// @brief Draws all active projectiles.
/// &lt;/summary&gt;
/// &lt;param name=&quot;window&quot;&gt;The SFML render window&lt;/param&gt; 
void render(sf::RenderWindow &amp; window);
</code></pre>

<p>Note that in the implementation of the <code>render()</code> function, we have this line:</p>
<pre><code>window.draw(m_projectiles.at(i).m_projectile);
</code></pre>

<p><code>m_projectile</code> is a <code>sf::Sprite</code> which is a private property of the <code>Projectile</code> class. So how can this class access the private member variable
of class <code>Projectile</code>? In C++, we have a special mechanism to enable this behaviour by which one class can 'befriend' another. Which brings us
nicely to the Projectile class...</p>
<p>At the beginning of the declaration for class <code>Projectile</code>, we have:</p>
<pre><code>class Projectile
{
    // Allows the ProjectilePool direct access to the private members of Projectile.
    // This is so the ProjectilePool can access the Projectile sprite representation so it
    // can be rendered.
    friend class ProjectilePool;
</code></pre>

<p>The declaration <code>friend class ProjectilePool</code> enables the <code>ProjectilePool</code> class access the private member variables of class <code>Projectile</code> without
the need to provide a getter method. This is considered acceptable practice because the <code>Projectile</code> objects are tightly coupled to the <code>ProjectilePool</code>
class. </p>
<p>Let's start with a quick look at the private members of Projectile:</p>
<pre><code>private:
    bool Projectile::isOnScreen(sf::Vector2f position) const;

    // Max. update speed 
    static constexpr double s_MAX_SPEED { 1000.0 };

    // Movement speed.
    double m_speed { s_MAX_SPEED };

    // A sprite for the projectile.
    sf::Sprite m_projectile;

    // The bounding rectangle for this projectile.
    sf::IntRect m_projectileRect { 5, 178, 10, 6 }; 
</code></pre>

<p><code>isOnScreen()</code> is a private helper method that returns true if this projectile is on screen. 
<code>s_MAX_SPEED</code> is a constant value that we use to define the projectiles maximum speed.
The current movement speed of a projectile is stored in <code>m_speed</code>. 
<code>m_projectile</code> is our sprite representation of a projectile, while m_projectileRect defines the bounding rectangle for the projectile - this information is taken from the sprite sheet.</p>
<p>In the public interface, we have an <code>init()</code> member function that takes the same arguments as <code>ProjectilePool::init()</code>. This is how we initialise a Projectile - remember we don't create them as they exist already in the pool.
The primary job of the <code>update()</code> member function is to calculate the next screen position for the projectile, and to perform collision checking between the projectile and walls:</p>
<pre><code>/// &lt;summary&gt;
/// @brief Calculates the new position of the projectile.
/// If this projectile is currently in use (on screen, speed non-zero), it's next screen position
///  is calculated along a vector that extends directly from the tip of the tank turret.
/// If the newly calculated position is off-screen, then the projectile speed is reset to 0.
/// Otherwise (projectile still on-screen), a collision check is performed between the projectile
///  and every wall. If the projectile collides with a wall, it's speed is reset to 0.
/// &lt;/summary&gt;
/// &lt;param name=&quot;dt&quot;&gt;The delta time&lt;/param&gt;
/// &lt;param name=&quot;wallSprites&quot;&gt;A reference to the container of wall sprites&lt;/param&gt;
/// &lt;returns&gt;True if this projectile is currently not in use (i.e. speed is zero).&lt;/returns&gt;
bool update(double dt, std::vector&lt;sf::Sprite&gt; &amp; wallSprites);
</code></pre>

<p><strong>Exercise 1</strong>: Add the <code>ProjectilePool</code> as a data member of class <code>Tank</code> called <code>m_pool</code>. (Note: this is an example of composition - a Tank 'has a' projectile pool).</p>
<p><strong>Exercise 2</strong>: Add the following member function to class <code>Tank</code>:</p>
<p>Tank.h</p>
<pre><code>/// &lt;summary&gt;
/// @brief Generates a request to fire a projectile.
/// A projectile will be fired from the tip of the turret only if time limit between shots
///  has expired. Fire requests are not queued.
/// &lt;/summary&gt;
void requestFire();
</code></pre>

<p>Tank.cpp</p>
<pre><code>////////////////////////////////////////////////////////////
void Tank::requestFire()
{
    m_fireRequested = true;
    if (m_shootTimer == s_TIME_BETWEEN_SHOTS)
    {       
        sf::Vector2f tipOfTurret(m_turret.getPosition().x + 2.0f, m_turret.getPosition().y);
        tipOfTurret.x += std::cos(MathUtility::DEG_TO_RAD  * m_turret.getRotation()) * ((m_turret.getLocalBounds().top + m_turret.getLocalBounds().height) * 1.7f);
        tipOfTurret.y += std::sin(MathUtility::DEG_TO_RAD  * m_turret.getRotation()) * ((m_turret.getLocalBounds().top + m_turret.getLocalBounds().height) * 1.7f);
        m_pool.create(m_texture, tipOfTurret.x, tipOfTurret.y, m_turret.getRotation());
    }
}
</code></pre>

<p>This new member function will request a projectile from the pool and position it at the tip of the tank turret. </p>
<p>Add the constant <code>s_TIME_BETWEEN_SHOTS</code> to class Tank as follows:</p>
<pre><code>// The delay time between shots in milliseconds.
static int const s_TIME_BETWEEN_SHOTS { 800 };
</code></pre>

<p>You will also need to add member variables <code>m_fireRequested</code> and <code>m_shootTimer</code>. Don't forget to initialise these variables to sensible values.</p>
<p>Make sure the project builds ok before proceeding.</p>
<p><strong>Exercise 3</strong>: Add the following logic to class <code>Tank</code>. If fire is pressed, call the new <code>Tank::requestFire()</code> member function. Build and run project to test. A projectile should appear at the tip of tank turret. (Hint: if you see nothing, remember that projectiles need to be drawn).</p>
<p>Try rotating the turret and fire again. Does the projectile appear in the correct place?</p>
<p><strong>Exercise 4</strong>: Now add the following logic to <code>Tank::update()</code>. If a fire request has been generated and the shoot timer has not reached zero, then decrement the shoot timer by the delta time (<code>dt</code>). Otherwise, reset the shoot timer and set the fire requested status to <code>false</code>. Build and run project to test.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
