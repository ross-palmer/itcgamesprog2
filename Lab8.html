<!DOCTYPE html>
<html>
<head>
<title>Lab8</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Lab 8: Game states</h2>
<p><strong>To be completed by:</strong> Week 20 (Fri 14/2)</p>
<p>Learning Outcomes:</p>
<ul>
<li>Implement a simple HUD system.</li>
<li>Implement game states for normal game mode (running), win and lose.</li>
</ul>
<p><strong>8.1 Introduction</strong></p>
<p>In this lab, we will learn how to build a very simple HUD and manage some basic game states. We will start with the game states first. 
Add a header file called GameState.h to your project with the following:</p>
<pre><code>#pragma once

enum class GameState
{
    GAME_RUNNING,
    GAME_WIN,
    GAME_LOSE
};
</code></pre>

<p>These will represent our three basic game states, which are normal (game running), game win (i.e. player wins) and game lose.
For the purposes of this exercise, the game win state will occur when the player fires a shell that hits the AI tank and 
the game lose state will occur when the AI tank simply collides with the player tank.
Open Game.h and add the following member variable:</p>
<pre><code>// The initial game state set to GAME_RUNNING
GameState m_gameState { GameState::GAME_RUNNING };
</code></pre>

<p>Don't forget to #include &quot;GameState.h&quot; at the top of your header file.</p>
<p>Shortly you will write some new logic for the Game::update() member function to use these new game states.</p>
<p>Next, in TankAI.h, add a new member function to check for AI/player tank collisions:</p>
<pre><code>/// &lt;summary&gt;
/// @brief Checks for collision between the AI and player tanks.
///
/// &lt;/summary&gt;
/// &lt;param name=&quot;player&quot;&gt;The player tank instance&lt;/param&gt;
/// &lt;returns&gt;True if collision detected between AI and player tanks.&lt;/returns&gt;
bool collidesWithPlayer(Tank const &amp; playerTank) const;
</code></pre>

<p>And add the implementation below to Tank.cpp</p>
<pre><code>bool TankAi::collidesWithPlayer(Tank const &amp; playerTank) const
{
    // Checks if the AI tank has collided with the player tank.
    if (CollisionDetector::collision(m_turret, playerTank.getTurret()) ||
        CollisionDetector::collision(m_tankBase, playerTank.getBase()))
    {
        return true;
    }
    return false;
}
</code></pre>

<p>Don't forget to #include &quot;CollisionDetector.h&quot; as it is called in the above function. You will also need to provide getter methods (i.e. <code>Tank::getTurret()</code> and <code>Tank::getBase()</code>) in class <code>Tank</code> to return the turret sprite and tank base sprite respectively.</p>
<p>Next, add the HUD class as follows. Starting with HUD.h below - the comments indicate what each member function does:</p>
<pre><code>#pragma once

#include &lt;SFML/Graphics.hpp&gt;
#include &quot;GameState.h&quot;

/// &lt;summary&gt;
/// @brief A basic HUD implementation.
/// 
/// Shows current game state only.
/// &lt;/summary&gt;

class HUD
{
public:
    /// &lt;summary&gt;
    /// @brief Default constructor that stores a font for the HUD and initialises the general HUD appearance.
    /// &lt;/summary&gt;
    HUD(sf::Font &amp; hudFont); 

    /// &lt;summary&gt;
    /// @brief Checks the current game state and sets the appropriate status text on the HUD.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;gameState&quot;&gt;The current game state&lt;/param&gt;
    void update(GameState const &amp; gameState);

    /// &lt;summary&gt;
    /// @brief Draws the HUD outline and text.
    ///
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;window&quot;&gt;The SFML Render window&lt;/param&gt;
    void render(sf::RenderWindow &amp; window);

private:
    // The font for this HUD.
    sf::Font m_textFont;        

    // A container for the current HUD text.
    sf::Text m_gameStateText;   

    // A simple background shape for the HUD.
    sf::RectangleShape m_hudOutline; 
};
</code></pre>

<p>And the implementation in HUD.cpp</p>
<pre><code>#include &quot;HUD.h&quot;

////////////////////////////////////////////////////////////
HUD::HUD(sf::Font &amp; hudFont)
: m_textFont(hudFont)
{
    m_gameStateText.setFont(hudFont);
    m_gameStateText.setCharacterSize(30);
    m_gameStateText.setFillColor(sf::Color::Blue);
    m_gameStateText.setPosition(sf::Vector2f(480, 5));
    m_gameStateText.setString(&quot;Game Running&quot;);

    //Setting up our hud properties 
    m_hudOutline.setSize(sf::Vector2f(1440.0f, 40.0f));
    m_hudOutline.setFillColor(sf::Color(0, 0, 0, 38));
    m_hudOutline.setOutlineThickness(-.5f);
    m_hudOutline.setOutlineColor(sf::Color(0, 0, 0, 100));
    m_hudOutline.setPosition(0, 0);
}

////////////////////////////////////////////////////////////
void HUD::update(GameState const &amp; gameState)
{
    switch (gameState)
    {
    case GameState::GAME_RUNNING:
        break;
    case GameState::GAME_WIN:
        m_gameStateText.setString(&quot;You Won&quot;);
        break;
    case GameState::GAME_LOSE:
        m_gameStateText.setString(&quot;You Lost&quot;);
        break;
    default:
        break;
    }
}

void HUD::render(sf::RenderWindow &amp; window) 
{
    window.draw(m_hudOutline);
    window.draw(m_gameStateText);
}
</code></pre>

<p>We can now add the HUD to our Game class. Open Game.h and add the following new member variables:</p>
<pre><code>// The font to be used for the HUD.
sf::Font m_font;

// The game HUD instance.
HUD m_hud; 
</code></pre>

<p>Again, don't forget to #include &quot;HUD.h&quot;</p>
<p>In Game.cpp, initialise the HUD instance in the constructor initialiser list:</p>
<pre><code>, m_aiTank(m_texture, m_wallSprites)
, m_hud(m_font) // Add this line
</code></pre>

<p>Note that the font (<code>m_font</code>) has not yet been loaded. This is fine as we are passing <code>m_font</code> by reference to the HUD constructor. This approach works as long as
we load the font before attempting to use it in the HUD class. Before the end of the Game constructor body, load the HUD font like this:</p>
<pre><code>if (!m_font.loadFromFile(&quot;./resources/fonts/akashi.ttf&quot;))
{
    std::string s(&quot;Error loading font&quot;);
    throw std::exception(s.c_str());
}
</code></pre>

<p>This assumes you have a font file with the above name in your <code>resources/fonts</code> folder, but you can use a different font if you wish.</p>
<p><strong>Exercise 1</strong>: Open the <code>Game::update()</code> member function. Rewrite the member function so incorporate the following logic:</p>
<ul>
<li>Update the HUD</li>
<li>Check for collision with the player tank</li>
<li>If there is a collision, set the game state to GAME_LOSE</li>
<li>Check the value of the current game state (use a switch statement for this)</li>
<li>If GAME_RUNNING, update the player and AI tanks.</li>
<li>Do nothing for GAME<em>WIN or GAME</em>LOSE for now.</li>
</ul>
<p>Build and run the project - you should see a HUD with the message GAME_RUNNING. When the AI tank collides with the player tank, 
the HUD should update with the message &quot;You Lost&quot;.</p>
<p><strong>Exercise 2</strong>: After the GAME_LOSE game state is detected, add a short delay so the game restarts automatically. Use the delta time
value (<code>dt</code>) passed into <code>Game::update()</code> to keep track of the elapsed time.</p>
<p><strong>Exercise 3</strong>: Add the appropriate logic for GAME_WIN, i.e. you will need to check if the player hits the AI tank with a projectile.
There is a bit of work to complete this exercise, so I have given you some hints below - there are some pieces you have to work out.</p>
<ol>
<li>
<p>The Projectile has a member function that checks for projectile/wall collisions - change this so it can also check for projectile/AI tank collisions.
In C++, a function can return two values by using the built-in <code>std::pair</code> template class, for example to return two <code>bool</code>'s from a function</p>
<p><pre><code>// std::pair&lt;bool, bool&gt; result = checkCollisions(); 
if (result.first)
{
   // Then the first bool is true...
}
else if (result.second)
{
	// Then the second bool is true...
}</pre></code></p>
</li>
<p>So the return type for <code>Projectile::update()</code> will no longer be a <code>bool</code>, but rather a <code>std::pair&lt;bool,bool&gt;</code></p>
<li>
<p>Because <code>Projectile::update()</code> needs to check for projectile/AI Tank collisions, it needs to know about the sprite representation of the AI tank.
This can be passed in also using <code>std::pair</code>, so <code>update()</code> now looks like:</p>
<p><pre><code>std::pair&lt;bool, bool&gt; Projectile::update(double dt, std::vector&lt;sf::Sprite&gt; &amp; wallSprites, std::pair&lt;sf::Sprite, sf::Sprite&gt; aiTankSprites)</pre></code></p>
</li>
<p>and you will have two separate collision checks inside the function, one to check for projectile/wall collisions and another to check for projectile/AI Tank collisions.</p>
<li>
<p>The Tank class controls the projectiles, so you will need to pass the AI tank as a parameter to <code>Tank::update()</code>. Be careful when including the header for class TankAI, 
as TankAI already includes class Tank (because it needs the Player position). A foward reference will help here, i.e. before the declaration of the TankAI class, we write:</p>
<p><pre><code>class Tank; // forward reference, do not #include &quot;Tank.h&quot; yet...</p>
<p>class TankAi
{
  // Body of class TankAI
}</p>
#include &quot;Tank.h&quot; // The include goes at the BOTTOM of the header file in TankAI.h</pre></code>
</li>
<li>
<p>Refactor the <code>ProjectilePool::update()</code> method so the inner for loop looks like this:</p>
<p><pre><code>for (int i = 0; i &lt; s<em>POOL</em>SIZE; i++)
{
  result = m_projectiles.at(i).update(dt, wallSprites, aiTankSprites);</p>
  if(result.first)
  {
    // If this projectile has expired, make it the next available.
    m_nextAvailable = i;
  }
  else
  {
    // So we know how many projectiles are active.
    activeCount++;
  }

  if (result.second)
  {
    hitCount++;
  }
}</pre></code>
<p></p>
</li>
<p>Note the new local variable <code>hitCount</code> - this will represent the number of projectile / player tank hits that have happened (you need to create and initialise this local variable). You now need to return
this value from the function. So <code>ProjectilePool::update()</code> looks like this:</p>
<pre><code>int ProjectilePool::update(double dt, std::vector&lt;sf::Sprite&gt; &amp; wallSprites, std::pair&lt;sf::Sprite, sf::Sprite&gt; aiTankSprites)
{
   ... 
   return hitCount
}
</code></pre>
<li>
<p>Finally, go to <code>Tank::update()</code> and locate the line where you update the projectile pool. You need to check the return value from <code>ProjectilePool::update()</code> - if
it is &gt; 0, then you need to apply damage to the AI tank (see step 6).</p>
</li>
<li>
<p>I suggest you write a member function called <code>takeDamage()</code> for the AI tank, and this gets called when a collision is detected
between the projectile and AI tank. The AI Tank might have a health property that decreases to 0 when it takes a hit.
If the AI health reaches 0, then the game state can be changed to GAME_WIN (i.e. player wins).</p>
</li>
</ol>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
